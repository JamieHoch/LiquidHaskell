<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title>/home/jamie/Documents/Master/MasterThesis/master-thesis-project/lh-thesis/src/Lib.hs</title>
</head>
<head>
<link type='text/css' rel='stylesheet' href='liquid.css' />
</head>

<body>
<hr>
Put mouse over identifiers to see inferred types
<pre><span class=hs-linenum> 1: </span><a class=annot href="#"><span class=annottext>GHC.Types.Module</span><span class='hs-keyword'>{-@</span></a> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--reflection"</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum> 2: </span><span class='hs-keyword'>{-@</span> <span class='hs-conid'>LIQUID</span> <span class='hs-str'>"--short-names"</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum> 3: </span>
<span class=hs-linenum> 4: </span><span class='hs-keyword'>module</span> <span class='hs-conid'>Lib</span> <span class='hs-keyword'>where</span>
<span class=hs-linenum> 5: </span>
<span class=hs-linenum> 6: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Prelude</span> <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span><span class='hs-varid'>length</span><span class='hs-layout'>)</span>
<span class=hs-linenum> 7: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Language.Haskell.Liquid.ProofCombinators</span>
<span class=hs-linenum> 8: </span><span class='hs-keyword'>import</span> <span class='hs-conid'>Language.Haskell.Liquid.RTick</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>RTick</span>
<span class=hs-linenum> 9: </span>
<span class=hs-linenum>10: </span>
<span class=hs-linenum>11: </span><span class='hs-keyword'>data</span> <span class='hs-conid'>List</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nil</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Cons</span> <span class='hs-varid'>a</span> <span class='hs-layout'>(</span><span class='hs-conid'>List</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<span class=hs-linenum>12: </span>
<span class=hs-linenum>13: </span><span class='hs-comment'>-- push &amp; pop</span>
<span class=hs-linenum>14: </span>
<span class=hs-linenum>15: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>measure</span> <span class='hs-varid'>length</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>16: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>length</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{v:</span> <span class='hs-conid'>Int</span> <span class='hs-keyword'>| v = (len xs)}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>17: </span><span class='hs-definition'>length</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>18: </span><a class=annot href="#"><span class=annottext>forall a .
x1:[a] -&gt; {VV : GHC.Types.Int | VV == len x1
                                &amp;&amp; VV == length x1}</span><span class='hs-definition'>length</span></a> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Prim.Int# | v == 0}</span><span class='hs-num'>0</span></a>
<span class=hs-linenum>19: </span><span class='hs-definition'>length</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>1</span></a> <span class='hs-varop'>+</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len xs
                     &amp;&amp; v == length xs}</span><span class='hs-varid'>length</span></a> <a class=annot href="#"><span class=annottext>{v : [a] | v == xs
           &amp;&amp; pot v == len v
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a>
<span class=hs-linenum>20: </span>
<span class=hs-linenum>21: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>measure</span> <span class='hs-varid'>pot</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>22: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>pot</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span>  <span class='hs-keyword'>{v:</span> <span class='hs-conid'>Int</span> <span class='hs-keyword'>| v = (len xs)}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>23: </span><span class='hs-definition'>pot</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<span class=hs-linenum>24: </span><a class=annot href="#"><span class=annottext>forall a .
x1:[a] -&gt; {VV : GHC.Types.Int | VV == len x1
                                &amp;&amp; VV == pot x1}</span><span class='hs-definition'>pot</span></a> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{v : GHC.Prim.Int# | v == 0}</span><span class='hs-num'>0</span></a>
<span class=hs-linenum>25: </span><span class='hs-definition'>pot</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>1</span></a> <span class='hs-varop'>+</span> <a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v == len xs
                     &amp;&amp; v == pot xs}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>pot</span> <a class=annot href="#"><span class=annottext>{v : [a] | v == xs
           &amp;&amp; length v == len v
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>26: </span>
<span class=hs-linenum>27: </span><span class='hs-comment'>-- amortised cost 2</span>
<span class=hs-linenum>28: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>push</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>xs</span><span class='hs-conop'>:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{t:</span><span class='hs-conid'>Tick</span> <span class='hs-keyword'>{ys:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyword'>| len ys = 1 + (len xs) }</span> <span class='hs-keyword'>| (pot xs) + 2 &gt;= (tcost t) + (pot (tval t))}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>29: </span><a class=annot href="#"><span class=annottext>forall a .
x1:[a] -&gt; a -&gt; {t : (Language.Haskell.Liquid.RTick.Tick {ys : [a] | len ys == 1 + len x1}) | pot x1 + 2 &gt;= tcost t + pot (tval t)}</span><span class='hs-definition'>push</span></a> <a class=annot href="#"><span class=annottext>[a]</span><span class='hs-varid'>ls</span></a> <a class=annot href="#"><span class=annottext>a</span><span class='hs-varid'>a</span></a> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RTick.wait</span> <a class=annot href="#"><span class=annottext>{v : [a] | v == : a ls
           &amp;&amp; head v == a
           &amp;&amp; len v == 1 + len ls
           &amp;&amp; length v == 1 + length ls
           &amp;&amp; lqdc##$select v == a
           &amp;&amp; lqdc##$select v == ls
           &amp;&amp; pot v == 1 + pot ls
           &amp;&amp; tail v == ls}</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{VV : a | VV == a}</span><span class='hs-varid'>a</span></a><span class='hs-conop'>:</span><a class=annot href="#"><span class=annottext>{v : [a] | v == ls
           &amp;&amp; length v == len v
           &amp;&amp; pot v == len v
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>ls</span></a><span class='hs-layout'>)</span>
<span class=hs-linenum>30: </span>
<span class=hs-linenum>31: </span><span class='hs-comment'>-- amortised cost 0</span>
<span class=hs-linenum>32: </span><span class='hs-keyword'>{-@</span> <span class='hs-varid'>pop</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>k</span><span class='hs-conop'>:</span><span class='hs-conid'>Nat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{xs:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyword'>| k &lt;= (len xs)}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>{t:</span><span class='hs-conid'>Tick</span> <span class='hs-keyword'>{ys:</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyword'>| (len ys) = (len xs) - k}</span> <span class='hs-keyword'>| (pot xs) + 2 &gt;= (tcost t) + (pot (tval t))}</span> <span class='hs-keyword'>@-}</span>
<span class=hs-linenum>33: </span><span class='hs-definition'>pop</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Tick</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<span class=hs-linenum>34: </span><a class=annot href="#"><span class=annottext>forall a .
x1:{VV : GHC.Types.Int | VV &gt;= 0} -&gt; x2:{v : [a] | x1 &lt;= len v} -&gt; {t : (Language.Haskell.Liquid.RTick.Tick {ys : [a] | len ys == len x2 - x1}) | pot x2 + 2 &gt;= tcost t + pot (tval t)}</span><span class='hs-definition'>pop</span></a> <span class='hs-num'>0</span> <a class=annot href="#"><span class=annottext>[a]</span><span class='hs-varid'>ys</span></a>     <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a .
      x1:a -&gt; {v : (Language.Haskell.Liquid.RTick.Tick a) | 0 == tcost v
                                                            &amp;&amp; v == return x1
                                                            &amp;&amp; v == Tick 0 x1
                                                            &amp;&amp; x1 == tval v} | VV == return}</span><span class='hs-conid'>RTick.return</span></a> <a class=annot href="#"><span class=annottext>{v : [a] | v == ys
           &amp;&amp; length v == len v
           &amp;&amp; pot v == len v
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>ys</span></a>     
<span class=hs-linenum>35: </span><span class='hs-definition'>pop</span> <span class='hs-varid'>k</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <a class=annot href="#"><span class=annottext>{VV : forall a .
      x1:GHC.Types.Int -&gt; x2:(Language.Haskell.Liquid.RTick.Tick a) -&gt; {v : (Language.Haskell.Liquid.RTick.Tick a) | v == Tick (x1 + tcost x2) (tval x2)
                                                                                                                     &amp;&amp; v == step x1 x2
                                                                                                                     &amp;&amp; tval x2 == tval v
                                                                                                                     &amp;&amp; x1 + tcost x2 == tcost v} | VV == step}</span><span class='hs-conid'>RTick.step</span></a> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>1</span></a> <a class=annot href="#"><span class=annottext>{v : (Language.Haskell.Liquid.RTick.Tick [a]) | pot xs + 2 &gt;= tcost v + pot (tval v)}</span><span class='hs-layout'>(</span></a><span class='hs-varid'>pop</span> <a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-layout'>(</span></a><a class=annot href="#"><span class=annottext>{v : GHC.Types.Int | v &gt;= 0}</span><span class='hs-varid'>k</span></a><span class='hs-comment'>-</span><a class=annot href="#"><span class=annottext>GHC.Types.Int</span><span class='hs-num'>1</span></a><span class='hs-layout'>)</span> <a class=annot href="#"><span class=annottext>{v : [a] | v == xs
           &amp;&amp; length v == len v
           &amp;&amp; pot v == len v
           &amp;&amp; len v &gt;= 0}</span><span class='hs-varid'>xs</span></a><span class='hs-layout'>)</span>
</pre>
</body>
</html>