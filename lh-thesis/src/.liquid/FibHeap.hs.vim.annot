1:1-1:1::FibHeap.$trModule :: "GHC.Types.Module"
41:1-41:16::FibHeap.notEmptyFibHeap :: "forall a .\nx1:(FibHeap.FibHeap a) -> {VV : GHC.Types.Bool | VV <=> notEmptyFibHeap x1}"
41:21-41:26::GHC.Types.False :: "{v : GHC.Types.Bool | not v\n                      && v == False}"
42:21-42:25::GHC.Types.True :: "{v : GHC.Types.Bool | v\n                      && v == True}"
47:1-47:15::FibHeap.isEmptyFibHeap :: "forall a .\nx1:(FibHeap.FibHeap a) -> {VV : GHC.Types.Bool | (VV\n                                                  && not (notEmptyFibHeap x1))\n                                                 || (notEmptyFibHeap x1\n                                                     && not VV)\n                                                 && (VV <=> isEmptyFibHeap x1)}"
47:20-47:24::GHC.Types.True :: "{v : GHC.Types.Bool | v\n                      && v == True}"
48:20-48:25::GHC.Types.False :: "{v : GHC.Types.Bool | not v\n                      && v == False}"
53:1-53:9::FibHeap.makeHeap :: "forall a . {VV : (FibHeap.FibHeap a) | not (notEmptyFibHeap VV)}"
59:1-59:10::FibHeap.singleton :: "forall a .\nx1:a -> {VV : (FibHeap.FibHeap a) | notEmptyFibHeap VV\n                                    && rank (minTree VV) == 1\n                                    && root (minTree VV) == x1\n                                    && subtrees (minTree VV) == []\n                                    && trees VV == []}"
59:11-59:12::x :: "a"
59:18-59:37::lq_anf$##7205759403792805598 :: "{v : (FibHeap.FibTree a) | marked v == False\n                           && root v == x}"
59:24-59:25::lq_anf$##7205759403792805596 :: "GHC.Types.Int"
59:26-59:27::x :: "{VV : a | VV == x}"
59:28-59:30::_ :: "{VV : forall a <p :: a a -> Bool>.\n      {v : [a]<\\x3 VV -> {VV : a<p x3> | true}> | v == []\n                                                  && len v == 0\n                                                  && lsize v == 0} | VV == []}"
59:31-59:36::GHC.Types.False :: "{v : GHC.Types.Bool | not v\n                      && v == False}"
59:38-59:40::_ :: "{VV : forall a <p :: a a -> Bool>.\n      {v : [a]<\\x3 VV -> {VV : a<p x3> | true}> | v == []\n                                                  && len v == 0\n                                                  && lsize v == 0} | VV == []}"
63:1-63:5::FibHeap.link :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:(FibHeap.FibTree a) -> x3:{t2 : (FibHeap.FibTree a) | rank x2 == rank t2} -> {v : (FibHeap.FibTree a) | (root v == root x2\n                                                                                                            && root x2 <= root x3)\n                                                                                                           || (root v == root x3\n                                                                                                               && root x3 <= root x2)\n                                                                                                           && rank v == 1 + rank x2}"
63:6-63:8::t1 :: "(FibHeap.FibTree a)"
63:26-63:28::t2 :: "{t2 : (FibHeap.FibTree a) | rank t1 == rank t2}"
64:7-64:8::x :: "{VV : a | VV == x}"
64:11-64:12::y :: "{VV : a | VV == y}"
64:15-64:44::FibHeap.Node :: "{VV : forall a .\n      x1:{v : GHC.Types.Int | v >= 0} -> x2:a -> x3:[(FibHeap.FibTree a)] -> x4:GHC.Types.Bool -> {v : (FibHeap.FibTree a) | v == Node x1 x2 x3 x4\n                                                                                                                             && marked v == x4\n                                                                                                                             && rank v == x1\n                                                                                                                             && root v == x2\n                                                                                                                             && size v == pow2 x1\n                                                                                                                             && subtrees v == x3} | VV == Node}"
64:20-64:27::lq_anf$##7205759403792805676 :: "GHC.Types.Int"
64:21-64:22::r :: "{v : GHC.Types.Int | v == r\n                     && v >= 0}"
64:25-64:26::lq_anf$##7205759403792805675 :: "GHC.Types.Int"
64:28-64:29::x :: "{VV : a | VV == x}"
64:30-64:38::lq_anf$##7205759403792805677 :: "{v : [(FibHeap.FibTree a)] | len v == 1 + len ts1\n                             && lqdc##$select v == ts1\n                             && tail v == ts1}"
64:31-64:33::lq_anf$##7205759403792805667 :: "{v : (FibHeap.FibTree a) | v == t2\n                           && rank t1 == rank v\n                           && root v == y\n                           && size v == pow2 (rank v)\n                           && subtrees v == ts2\n                           && 0 < size v}"
64:34-64:37::ts1 :: "{v : [(FibHeap.FibTree a)] | v == ts1\n                             && len v >= 0\n                             && lsize v >= len v}"
64:39-64:44::GHC.Types.False :: "{v : GHC.Types.Bool | not v\n                      && v == False}"
65:19-65:48::FibHeap.Node :: "{VV : forall a .\n      x1:{v : GHC.Types.Int | v >= 0} -> x2:a -> x3:[(FibHeap.FibTree a)] -> x4:GHC.Types.Bool -> {v : (FibHeap.FibTree a) | v == Node x1 x2 x3 x4\n                                                                                                                             && marked v == x4\n                                                                                                                             && rank v == x1\n                                                                                                                             && root v == x2\n                                                                                                                             && size v == pow2 x1\n                                                                                                                             && subtrees v == x3} | VV == Node}"
65:24-65:31::lq_anf$##7205759403792805672 :: "GHC.Types.Int"
65:25-65:26::r :: "{v : GHC.Types.Int | v == r\n                     && v >= 0}"
65:29-65:30::lq_anf$##7205759403792805671 :: "GHC.Types.Int"
65:32-65:33::y :: "{VV : a | VV == y}"
65:34-65:42::lq_anf$##7205759403792805673 :: "{v : [(FibHeap.FibTree a)] | len v == 1 + len ts2\n                             && lqdc##$select v == ts2\n                             && tail v == ts2}"
65:35-65:37::lq_anf$##7205759403792805666 :: "{v : (FibHeap.FibTree a) | v == t1\n                           && rank v == r\n                           && root v == x\n                           && size v == pow2 r\n                           && size v == pow2 (rank v)\n                           && subtrees v == ts1\n                           && 0 < size v}"
65:38-65:41::ts2 :: "{v : [(FibHeap.FibTree a)] | v == ts2\n                             && len v >= 0\n                             && lsize v >= len v}"
65:43-65:48::GHC.Types.False :: "{v : GHC.Types.Bool | not v\n                      && v == False}"
71:1-71:6::FibHeap.merge :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:(FibHeap.FibHeap a) -> x3:{VV : (FibHeap.FibHeap a) | notEmptyFibHeap VV} -> {VV : (FibHeap.FibHeap a) | notEmptyFibHeap VV\n                                                                                                            && (root (minTree VV) == root (minTree x2)\n                                                                                                                && root (minTree x2) < root (minTree x3))\n                                                                                                               || ((root (minTree x3) <= root (minTree x2)\n                                                                                                                    || not (notEmptyFibHeap x2))\n                                                                                                                   && root (minTree VV) == root (minTree x3))}"
71:9-71:10::h :: "{VV : (FibHeap.FibHeap a) | notEmptyFibHeap VV}"
71:13-71:14::h :: "{v : (FibHeap.FibHeap a) | notEmptyFibHeap v\n                           && (isEmptyFibHeap v\n                               && not (notEmptyFibHeap v))\n                              || (notEmptyFibHeap v\n                                  && not (isEmptyFibHeap v))\n                           && v == h\n                           && 0 < fibsize v}"
73:7-73:18::lq_anf$##7205759403792805603 :: "{VV : a | VV == root minTr1}"
73:12-73:18::minTr1 :: "{v : (FibHeap.FibTree a) | v == minTr1\n                           && size v == pow2 (rank v)\n                           && 0 < size v}"
73:21-73:32::lq_anf$##7205759403792805604 :: "{VV : a | VV == root minTr2}"
73:26-73:32::minTr2 :: "{v : (FibHeap.FibTree a) | v == minTr2\n                           && size v == pow2 (rank v)\n                           && 0 < size v}"
73:35-73:62::FibHeap.FH :: "{VV : forall a .\n      x1:(FibHeap.FibTree a) -> x2:[(FibHeap.FibTree a)] -> {v : (FibHeap.FibHeap a) | notEmptyFibHeap v\n                                                                                       && not (isEmptyFibHeap v)\n                                                                                       && v == FH x1 x2\n                                                                                       && fibsize v == size x1 + lsize x2\n                                                                                       && minTree v == x1\n                                                                                       && trees v == x2} | VV == FH}"
73:38-73:44::minTr1 :: "{v : (FibHeap.FibTree a) | v == minTr1\n                           && size v == pow2 (rank v)\n                           && 0 < size v}"
73:45-73:62::lq_anf$##7205759403792805610 :: "{v : [(FibHeap.FibTree a)] | head v == minTr2\n                             && lqdc##$select v == minTr2}"
73:46-73:52::minTr2 :: "{v : (FibHeap.FibTree a) | v == minTr2\n                           && size v == pow2 (rank v)\n                           && 0 < size v}"
73:53-73:56::ts2 :: "{v : [(FibHeap.FibTree a)] | v == ts2\n                             && len v >= 0\n                             && lsize v >= len v}"
73:58-73:61::ts1 :: "{v : [(FibHeap.FibTree a)] | v == ts1\n                             && len v >= 0\n                             && lsize v >= len v}"
74:19-74:46::FibHeap.FH :: "{VV : forall a .\n      x1:(FibHeap.FibTree a) -> x2:[(FibHeap.FibTree a)] -> {v : (FibHeap.FibHeap a) | notEmptyFibHeap v\n                                                                                       && not (isEmptyFibHeap v)\n                                                                                       && v == FH x1 x2\n                                                                                       && fibsize v == size x1 + lsize x2\n                                                                                       && minTree v == x1\n                                                                                       && trees v == x2} | VV == FH}"
74:22-74:28::minTr2 :: "{v : (FibHeap.FibTree a) | v == minTr2\n                           && size v == pow2 (rank v)\n                           && 0 < size v}"
74:29-74:46::lq_anf$##7205759403792805608 :: "{v : [(FibHeap.FibTree a)] | head v == minTr1\n                             && lqdc##$select v == minTr1}"
74:30-74:36::minTr1 :: "{v : (FibHeap.FibTree a) | v == minTr1\n                           && size v == pow2 (rank v)\n                           && 0 < size v}"
74:37-74:40::ts1 :: "{v : [(FibHeap.FibTree a)] | v == ts1\n                             && len v >= 0\n                             && lsize v >= len v}"
74:42-74:45::ts2 :: "{v : [(FibHeap.FibTree a)] | v == ts2\n                             && len v >= 0\n                             && lsize v >= len v}"
79:1-79:7::FibHeap.insert :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:(FibHeap.FibHeap a) -> x3:a -> {VV : (FibHeap.FibHeap a) | notEmptyFibHeap VV\n                                                              && (root (minTree VV) == root (minTree x2)\n                                                                  && root (minTree x2) <= x3)\n                                                                 || ((x3 <= root (minTree x2)\n                                                                      || not (notEmptyFibHeap x2))\n                                                                     && root (minTree VV) == x3)}"
79:8-79:9::h :: "(FibHeap.FibHeap a)"
79:10-79:11::x :: "a"
79:20-79:21::h :: "{v : (FibHeap.FibHeap a) | (isEmptyFibHeap v\n                            && not (notEmptyFibHeap v))\n                           || (notEmptyFibHeap v\n                               && not (isEmptyFibHeap v))\n                           && v == h\n                           && 0 < fibsize v}"
79:22-79:35::lq_anf$##7205759403792805611 :: "{v : (FibHeap.FibHeap a) | notEmptyFibHeap v\n                           && rank (minTree v) == 1\n                           && root (minTree v) == x\n                           && subtrees (minTree v) == []\n                           && trees v == []}"
79:33-79:34::x :: "{VV : a | VV == x}"
82:1-82:8::FibHeap.findMin :: "forall a . (GHC.Classes.Ord<[]> a) => (FibHeap.FibHeap a) -> a"
82:11-82:15::_ :: "{VV : forall a .\n      x1:(FibHeap.FibTree a) -> {VV : a | VV == root x1} | VV == root}"
82:18-82:25::_ :: "{VV : forall a .\n      x1:(FibHeap.FibHeap a) -> {v : (FibHeap.FibTree a) | v == minTree x1} | VV == minTree}"
86:1-86:12::FibHeap.consolidate :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\n{t : [(FibHeap.FibTree a)] | len t > 0} -> {v : [(FibHeap.FibTree a)] | len v > 0}"
86:19-86:22::lq_anf$##7205759403792805710 :: "{v : [(FibHeap.FibTree a)] | v == []\n                             && len v == 0\n                             && lsize v == 0}"
86:20-86:21::x :: "{v : (FibHeap.FibTree a) | v == x\n                           && size v == pow2 (rank v)\n                           && 0 < size v}"
87:22-87:39::Data.Foldable.$fFoldable[] :: "{v : (Data.Foldable.Foldable []) | v == $fFoldable[]}"
87:28-87:32::lq_anf$##7205759403792805707 :: "x1:[(FibHeap.FibTree a)] -> (FibHeap.FibTree a) -> {v : [(FibHeap.FibTree a)] | len v > 0\n                                                                                && len v <= len x1 + 1}"
87:33-87:36::lq_anf$##7205759403792805709 :: "{v : [(FibHeap.FibTree a)] | head v == x\n                             && lqdc##$select v == x}"
87:34-87:35::x :: "{v : (FibHeap.FibTree a) | v == x\n                           && size v == pow2 (rank v)\n                           && 0 < size v}"
87:37-87:39::ds_d33M :: "{v : [(FibHeap.FibTree a)] | len v >= 0\n                             && lsize v >= len v}"
90:5-90:9::meld :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:[(FibHeap.FibTree a)] -> (FibHeap.FibTree a) -> {v : [(FibHeap.FibTree a)] | len v > 0\n                                                                                && len v <= len x2 + 1}"
90:13-90:14::x :: "(FibHeap.FibTree a)"
90:17-90:20::lq_anf$##7205759403792805700 :: "{v : [(FibHeap.FibTree a)] | v == []\n                             && len v == 0\n                             && lsize v == 0}"
90:18-90:19::x :: "{v : (FibHeap.FibTree a) | v == x\n                           && size v == pow2 (rank v)\n                           && 0 < size v}"
91:25-91:31::lq_anf$##7205759403792805701 :: "{v : GHC.Types.Int | v == rank x\n                     && v >= 0}"
91:30-91:31::x :: "{v : (FibHeap.FibTree a) | v == x\n                           && size v == pow2 (rank v)\n                           && 0 < size v}"
91:35-91:42::lq_anf$##7205759403792805702 :: "{v : GHC.Types.Int | v == rank x'\n                     && v >= 0}"
91:40-91:42::x' :: "{v : (FibHeap.FibTree a) | v == x'\n                           && size v == pow2 (rank v)\n                           && 0 < size v}"
91:48-91:67::meld :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\nx2:[(FibHeap.FibTree a)] -> (FibHeap.FibTree a) -> {v : [(FibHeap.FibTree a)] | len v > 0\n                                                                                && len v <= len x2 + 1}"
91:53-91:55::xs :: "{v : [(FibHeap.FibTree a)] | v == xs\n                             && len v >= 0\n                             && lsize v >= len v}"
91:56-91:67::lq_anf$##7205759403792805706 :: "{v : (FibHeap.FibTree a) | (root v == root x\n                            && root x <= root x')\n                           || (root v == root x'\n                               && root x' <= root x)\n                           && rank v == 1 + rank x}"
91:62-91:63::x :: "{v : (FibHeap.FibTree a) | v == x\n                           && size v == pow2 (rank v)\n                           && 0 < size v}"
91:64-91:66::x' :: "{v : (FibHeap.FibTree a) | v == x'\n                           && size v == pow2 (rank v)\n                           && 0 < size v}"
92:27-92:28::x :: "{v : (FibHeap.FibTree a) | v == x\n                           && size v == pow2 (rank v)\n                           && 0 < size v}"
92:29-92:31::x' :: "{v : (FibHeap.FibTree a) | v == x'\n                           && size v == pow2 (rank v)\n                           && 0 < size v}"
92:32-92:34::xs :: "{v : [(FibHeap.FibTree a)] | v == xs\n                             && len v >= 0\n                             && lsize v >= len v}"
96:1-96:11::FibHeap.extractMin :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\n{t : [(FibHeap.FibTree a)] | len t > 0} -> ((FibHeap.FibTree a), [(FibHeap.FibTree a)])"
96:18-96:25::lq_anf$##7205759403792805624 :: "{v : [(FibHeap.FibTree a)] | v == []\n                             && len v == 0\n                             && lsize v == 0}"
96:19-96:20::t :: "{v : (FibHeap.FibTree a) | v == t\n                           && size v == pow2 (rank v)\n                           && 0 < size v}"
96:22-96:24::_ :: "{VV : forall a <p :: a a -> Bool>.\n      {v : [a]<\\x3 VV -> {VV : a<p x3> | true}> | v == []\n                                                  && len v == 0\n                                                  && lsize v == 0} | VV == []}"
98:10-98:12::t' :: "(FibHeap.FibTree a)"
98:14-98:17::ts' :: "[(FibHeap.FibTree a)]"
98:21-98:34::FibHeap.extractMin :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\n{t : [(FibHeap.FibTree a)] | len t > 0} -> ((FibHeap.FibTree a), [(FibHeap.FibTree a)])"
98:32-98:34::ds_d318 :: "{v : [(FibHeap.FibTree a)] | len v >= 0\n                             && lsize v >= len v}"
99:12-99:18::lq_anf$##7205759403792805619 :: "{VV : a | VV == root t}"
99:17-99:18::t :: "{v : (FibHeap.FibTree a) | v == t\n                           && size v == pow2 (rank v)\n                           && 0 < size v}"
99:21-99:28::lq_anf$##7205759403792805620 :: "{VV : a | VV == root t'}"
99:26-99:28::t' :: "{v : (FibHeap.FibTree a) | v == t'\n                           && size v == pow2 (rank v)\n                           && 0 < size v}"
99:34-99:41::GHC.Tuple.(,) :: "{VV : forall a b <p2 :: a b -> Bool>.\n      x1:a -> x2:{VV : b<p2 x1> | true} -> {v : (a, b)<\\x5 VV -> {VV : b<p2 x5> | true}> | v == (,) x1 x2\n                                                                                           && fst v == x1\n                                                                                           && lqdc##$select v == x1\n                                                                                           && lqdc##$select v == x2\n                                                                                           && snd v == x2\n                                                                                           && x_Tuple21 v == x1\n                                                                                           && x_Tuple22 v == x2} | VV == (,)}"
99:35-99:36::t :: "{v : (FibHeap.FibTree a) | v == t\n                           && size v == pow2 (rank v)\n                           && 0 < size v}"
99:38-99:40::ds_d318 :: "{v : [(FibHeap.FibTree a)] | len v >= 0\n                             && lsize v >= len v}"
99:47-99:58::GHC.Tuple.(,) :: "{VV : forall a b <p2 :: a b -> Bool>.\n      x1:a -> x2:{VV : b<p2 x1> | true} -> {v : (a, b)<\\x5 VV -> {VV : b<p2 x5> | true}> | v == (,) x1 x2\n                                                                                           && fst v == x1\n                                                                                           && lqdc##$select v == x1\n                                                                                           && lqdc##$select v == x2\n                                                                                           && snd v == x2\n                                                                                           && x_Tuple21 v == x1\n                                                                                           && x_Tuple22 v == x2} | VV == (,)}"
99:48-99:50::t' :: "{v : (FibHeap.FibTree a) | v == t'\n                           && size v == pow2 (rank v)\n                           && 0 < size v}"
99:52-99:53::t :: "{v : (FibHeap.FibTree a) | v == t\n                           && size v == pow2 (rank v)\n                           && 0 < size v}"
99:54-99:57::ts' :: "{v : [(FibHeap.FibTree a)] | v == ts'\n                             && len v >= 0\n                             && lsize v >= len v}"
104:1-104:10::FibHeap.deleteMin :: "forall a .\n(GHC.Classes.Ord<[]> a) =>\n{VV : (FibHeap.FibHeap a) | notEmptyFibHeap VV} -> (FibHeap.FibHeap a)"
104:38-104:39::_ :: "{VV : forall a .\n      {v : (FibHeap.FibHeap a) | isEmptyFibHeap v\n                                 && not (notEmptyFibHeap v)\n                                 && v == E} | VV == E}"
105:36-105:49::FibHeap.FH :: "{VV : forall a .\n      x1:(FibHeap.FibTree a) -> x2:[(FibHeap.FibTree a)] -> {v : (FibHeap.FibHeap a) | notEmptyFibHeap v\n                                                                                       && not (isEmptyFibHeap v)\n                                                                                       && v == FH x1 x2\n                                                                                       && fibsize v == size x1 + lsize x2\n                                                                                       && minTree v == x1\n                                                                                       && trees v == x2} | VV == FH}"
105:39-105:45::minTr' :: "{v : (FibHeap.FibTree a) | v == minTr'\n                           && size v == pow2 (rank v)\n                           && 0 < size v}"
105:46-105:49::ts' :: "{v : [(FibHeap.FibTree a)] | v == ts'\n                             && len v >= 0\n                             && lsize v >= len v}"
106:6-106:12::minTr' :: "(FibHeap.FibTree a)"
106:14-106:17::ts' :: "[(FibHeap.FibTree a)]"
106:21-106:31::lq_anf$##7205759403792805724 :: "{v : [(FibHeap.FibTree a)] | len v > 0} -> ((FibHeap.FibTree a), [(FibHeap.FibTree a)])"
106:34-106:68::lq_anf$##7205759403792805727 :: "{v : [(FibHeap.FibTree a)] | len v > 0}"
106:46-106:68::lq_anf$##7205759403792805726 :: "[(FibHeap.FibTree a)]"
106:47-106:61::lq_anf$##7205759403792805725 :: "[(FibHeap.FibTree a)]"
106:56-106:61::ds_d35A :: "{v : (FibHeap.FibTree a) | size v == pow2 (rank v)\n                           && 0 < size v}"
106:65-106:67::ds_d35B :: "{v : [(FibHeap.FibTree a)] | len v >= 0\n                             && lsize v >= len v}"
107:55-107:68::FibHeap.FH :: "{VV : forall a .\n      x1:(FibHeap.FibTree a) -> x2:[(FibHeap.FibTree a)] -> {v : (FibHeap.FibHeap a) | notEmptyFibHeap v\n                                                                                       && not (isEmptyFibHeap v)\n                                                                                       && v == FH x1 x2\n                                                                                       && fibsize v == size x1 + lsize x2\n                                                                                       && minTree v == x1\n                                                                                       && trees v == x2} | VV == FH}"
107:58-107:64::minTr' :: "{v : (FibHeap.FibTree a) | v == minTr'\n                           && size v == pow2 (rank v)\n                           && 0 < size v}"
107:65-107:68::ts' :: "{v : [(FibHeap.FibTree a)] | v == ts'\n                             && len v >= 0\n                             && lsize v >= len v}"
108:6-108:12::minTr' :: "(FibHeap.FibTree a)"
108:14-108:17::ts' :: "[(FibHeap.FibTree a)]"
108:21-108:31::lq_anf$##7205759403792805721 :: "{v : [(FibHeap.FibTree a)] | len v > 0} -> ((FibHeap.FibTree a), [(FibHeap.FibTree a)])"
108:34-108:59::lq_anf$##7205759403792805723 :: "{v : [(FibHeap.FibTree a)] | len v > 0}"
108:46-108:59::lq_anf$##7205759403792805722 :: "[(FibHeap.FibTree a)]"
108:47-108:52::lq_anf$##7205759403792805719 :: "{v : [(FibHeap.FibTree a)] | v == subtr\n                             && v == : x xs\n                             && head v == x\n                             && len v == 1 + len xs\n                             && lqdc##$select v == x\n                             && lqdc##$select v == xs\n                             && lsize v == size x + lsize xs\n                             && tail v == xs\n                             && len v >= 0\n                             && lsize v >= len v}"
108:56-108:58::ds_d35B :: "{v : [(FibHeap.FibTree a)] | len v >= 0\n                             && lsize v >= len v}"
111:1-111:9::FibHeap.fromList :: "forall a . (GHC.Classes.Ord<[]> a) => [a] -> (FibHeap.FibHeap a)"
111:10-111:12::xs :: "[a]"
111:21-111:27::lq_anf$##7205759403792805612 :: "x1:(FibHeap.FibHeap a) -> x2:a -> {v : (FibHeap.FibHeap a) | notEmptyFibHeap v\n                                                             && (root (minTree v) == root (minTree x1)\n                                                                 && root (minTree x1) <= x2)\n                                                                || ((x2 <= root (minTree x1)\n                                                                     || not (notEmptyFibHeap x1))\n                                                                    && root (minTree v) == x2)}"
111:28-111:29::_ :: "{VV : forall a .\n      {v : (FibHeap.FibHeap a) | isEmptyFibHeap v\n                                 && not (notEmptyFibHeap v)\n                                 && v == E} | VV == E}"
111:30-111:32::xs :: "{v : [a] | v == xs\n           && len v >= 0\n           && lsize v >= len v}"
118:1-118:8::FibHeap.fibsize :: "forall a .\nx1:{VV : (FibHeap.FibHeap a) | notEmptyFibHeap VV} -> {VV : GHC.Types.Int | VV == fibsize x1\n                                                                            && 0 < VV}"
118:25-118:35::lq_anf$##7205759403792805694 :: "{v : GHC.Types.Int | v == pow2 (rank minTr)\n                     && v == size minTr\n                     && 0 < v}"
118:30-118:35::minTr :: "{v : (FibHeap.FibTree a) | v == minTr\n                           && size v == pow2 (rank v)\n                           && 0 < size v}"
118:38-118:46::lq_anf$##7205759403792805695 :: "{v : GHC.Types.Int | v == lsize ts\n                     && v >= len ts}"
118:44-118:46::ts :: "{v : [(FibHeap.FibTree a)] | v == ts\n                             && len v >= 0\n                             && lsize v >= len v}"
123:1-123:6::FibHeap.lsize :: "forall a .\nx1:[(FibHeap.FibTree a)] -> {VV : GHC.Types.Int | VV == lsize x1\n                                                  && VV >= len x1}"
123:12-123:13::lq_anf$##7205759403792805689 :: "{v : GHC.Prim.Int# | v == 0}"
124:16-124:22::lq_anf$##7205759403792805690 :: "{v : GHC.Types.Int | v == pow2 (rank t)\n                     && v == size t\n                     && 0 < v}"
124:21-124:22::t :: "{v : (FibHeap.FibTree a) | v == t\n                           && size v == pow2 (rank v)\n                           && 0 < size v}"
124:25-124:33::lq_anf$##7205759403792805691 :: "{v : GHC.Types.Int | v == lsize ts\n                     && v >= len ts}"
124:31-124:33::ts :: "{v : [(FibHeap.FibTree a)] | v == ts\n                             && len v >= 0}"
129:1-129:5::FibHeap.pow2 :: "{VV : GHC.Types.Int | VV >= 0} -> {VV : GHC.Types.Int | 0 < VV}"
129:10-129:11::lq_anf$##7205759403792805686 :: "{v : GHC.Prim.Int# | v == 1}"
130:10-130:11::lq_anf$##7205759403792805681 :: "GHC.Types.Int"
130:14-130:24::lq_anf$##7205759403792805685 :: "{VV : GHC.Types.Int | 0 < VV}"
130:19-130:24::lq_anf$##7205759403792805684 :: "GHC.Types.Int"
130:20-130:21::ds_d2ZD :: "{v : GHC.Types.Int | v >= 0}"
130:22-130:23::lq_anf$##7205759403792805683 :: "GHC.Types.Int"
135:1-135:5::FibHeap.size :: "forall a .\nx1:(FibHeap.FibTree a) -> {VV : GHC.Types.Int | VV == pow2 (rank x1)\n                                                && VV == size x1\n                                                && 0 < VV}"
135:23-135:29::FibHeap.pow2 :: "x1:{v : GHC.Types.Int | v >= 0} -> {v : GHC.Types.Int | v == pow2 x1\n                                                        && v == (if 0 == x1 then 1 else 2 * pow2 (x1 - 1))\n                                                        && 0 < v}"
135:28-135:29::r :: "{v : GHC.Types.Int | v == r\n                     && v >= 0}"