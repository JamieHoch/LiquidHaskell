1:1-1:1::$trModule :: "GHC.Types.Module"
18:1-18:7::length :: "forall a .\nx1:[a] -> {VV : GHC.Types.Int | VV == len x1\n                                && VV == length x1}"
18:17-18:18::lq_anf$##7205759403792803345 :: "{v : GHC.Prim.Int# | v == 0}"
19:17-19:18::lq_anf$##7205759403792803347 :: "GHC.Types.Int"
19:21-19:30::lq_anf$##7205759403792803348 :: "{v : GHC.Types.Int | v == len xs\n                     && v == length xs}"
19:28-19:30::xs :: "{v : [a] | v == xs\n           && pot v == len v\n           && len v >= 0}"
24:1-24:4::pot :: "forall a .\nx1:[a] -> {VV : GHC.Types.Int | VV == len x1\n                                && VV == pot x1}"
24:14-24:15::lq_anf$##7205759403792803350 :: "{v : GHC.Prim.Int# | v == 0}"
25:14-25:15::lq_anf$##7205759403792803352 :: "GHC.Types.Int"
25:18-25:26::lq_anf$##7205759403792803353 :: "{v : GHC.Types.Int | v == len xs\n                     && v == pot xs}"
25:23-25:25::xs :: "{v : [a] | v == xs\n           && length v == len v\n           && len v >= 0}"
29:1-29:5::push :: "forall a .\nx1:[a] -> a -> {t : (Language.Haskell.Liquid.RTick.Tick {ys : [a] | len ys == 1 + len x1}) | pot x1 + 2 >= tcost t + pot (tval t)}"
29:6-29:8::ls :: "[a]"
29:9-29:10::a :: "a"
29:24-29:30::lq_anf$##7205759403792803354 :: "{v : [a] | v == : a ls\n           && head v == a\n           && len v == 1 + len ls\n           && length v == 1 + length ls\n           && lqdc##$select v == a\n           && lqdc##$select v == ls\n           && pot v == 1 + pot ls\n           && tail v == ls}"
29:25-29:26::a :: "{VV : a | VV == a}"
29:27-29:29::ls :: "{v : [a] | v == ls\n           && length v == len v\n           && pot v == len v\n           && len v >= 0}"
34:1-34:4::pop :: "forall a .\nx1:{VV : GHC.Types.Int | VV >= 0} -> x2:{v : [a] | x1 <= len v} -> {t : (Language.Haskell.Liquid.RTick.Tick {ys : [a] | len ys == len x2 - x1}) | pot x2 + 2 >= tcost t + pot (tval t)}"
34:7-34:9::ys :: "[a]"
34:16-34:31::return :: "{VV : forall a .\n      x1:a -> {v : (Language.Haskell.Liquid.RTick.Tick a) | 0 == tcost v\n                                                            && v == return x1\n                                                            && v == Tick 0 x1\n                                                            && x1 == tval v} | VV == return}"
34:29-34:31::ys :: "{v : [a] | v == ys\n           && length v == len v\n           && pot v == len v\n           && len v >= 0}"
35:16-35:43::step :: "{VV : forall a .\n      x1:GHC.Types.Int -> x2:(Language.Haskell.Liquid.RTick.Tick a) -> {v : (Language.Haskell.Liquid.RTick.Tick a) | v == Tick (x1 + tcost x2) (tval x2)\n                                                                                                                     && v == step x1 x2\n                                                                                                                     && tval x2 == tval v\n                                                                                                                     && x1 + tcost x2 == tcost v} | VV == step}"
35:27-35:28::lq_anf$##7205759403792803360 :: "GHC.Types.Int"
35:29-35:43::lq_anf$##7205759403792803364 :: "{v : (Language.Haskell.Liquid.RTick.Tick [a]) | pot xs + 2 >= tcost v + pot (tval v)}"
35:34-35:39::lq_anf$##7205759403792803363 :: "GHC.Types.Int"
35:35-35:36::ds_d2wu :: "{v : GHC.Types.Int | v >= 0}"
35:37-35:38::lq_anf$##7205759403792803362 :: "GHC.Types.Int"
35:40-35:42::xs :: "{v : [a] | v == xs\n           && length v == len v\n           && pot v == len v\n           && len v >= 0}"